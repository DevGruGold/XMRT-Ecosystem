name: ‚õèÔ∏è XMRT Miner Contribution Tracker
true:
  push:
    branches:
    - main
    - develop
  pull_request:
    types:
    - opened
    - closed
    - merged
  issues:
    types:
    - opened
    - closed
  release:
    types:
    - published
  schedule:
  - cron: 0 0 * * *
  workflow_dispatch:
    inputs:
      tracking_period:
        description: Period to track contributions
        required: true
        default: '7'
        type: choice
        options:
        - '1'
        - '7'
        - '30'
        - '90'
      reward_calculation:
        description: Calculate rewards for contributions
        required: true
        default: 'true'
        type: boolean
env:
  XMRT_TOKEN_SYMBOL: XMRT
  BASE_REWARD_MULTIPLIER: 100
  CONTRIBUTION_WEIGHTS: "{\n  \"commit\": 10,\n  \"pull_request\": 25,\n  \"issue\"\
    : 15,\n  \"review\": 20,\n  \"release\": 50,\n  \"documentation\": 30,\n  \"bug_fix\"\
    : 40,\n  \"feature\": 35,\n  \"security\": 60\n}\n"
jobs:
  track-contributions:
    name: ‚õèÔ∏è Track Miner Contributions
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
    - name: üì• Checkout Repository
      uses: actions/checkout@v4
    - name: üêç Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
    - name: üîß Install Dependencies
      run: 'python -m pip install --upgrade pip

        pip install PyGithub python-dotenv requests pandas matplotlib seaborn

        '
    - name: ‚õèÔ∏è Analyze Miner Contributions
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        TRACKING_DAYS: ${{ github.event.inputs.tracking_period || '7' }}
      run: "python -c \"\nimport json\nimport os\nfrom datetime import datetime, timezone,\
        \ timedelta\nfrom github import Github, Auth\nfrom collections import defaultdict\n\
        import requests\n\n# Initialize GitHub\nauth = Auth.Token(os.environ['GITHUB_TOKEN'])\n\
        github = Github(auth=auth)\nrepo = github.get_repo('${{ github.repository\
        \ }}')\n\n# Configuration\ntracking_days = int(os.environ.get('TRACKING_DAYS',\
        \ 7))\ncutoff_date = datetime.now(timezone.utc) - timedelta(days=tracking_days)\n\
        \n# Contribution weights\nweights = {\n    'commit': 10,\n    'pull_request':\
        \ 25,\n    'issue': 15,\n    'review': 20,\n    'release': 50,\n    'documentation':\
        \ 30,\n    'bug_fix': 40,\n    'feature': 35,\n    'security': 60\n}\n\nprint(f'‚õèÔ∏è\
        \ Tracking contributions for the last {tracking_days} days...')\nprint(f'\U0001F4C5\
        \ Cutoff date: {cutoff_date.strftime(\\\"%Y-%m-%d %H:%M:%S\\\")} UTC')\n\n\
        # Initialize contribution tracking\nminers = defaultdict(lambda: {\n    'contributions':\
        \ defaultdict(int),\n    'total_score': 0,\n    'details': [],\n    'profile':\
        \ {}\n})\n\n# Track commits\nprint('\U0001F4DD Analyzing commits...')\ncommits\
        \ = repo.get_commits(since=cutoff_date)\nfor commit in commits:\n    if commit.author:\n\
        \        author = commit.author.login\n        miners[author]['contributions']['commits']\
        \ += 1\n        miners[author]['total_score'] += weights['commit']\n     \
        \   \n        # Analyze commit for special categories\n        commit_message\
        \ = commit.commit.message.lower()\n        if 'fix' in commit_message or 'bug'\
        \ in commit_message:\n            miners[author]['contributions']['bug_fixes']\
        \ += 1\n            miners[author]['total_score'] += weights['bug_fix'] -\
        \ weights['commit']\n        elif 'feat' in commit_message or 'feature' in\
        \ commit_message:\n            miners[author]['contributions']['features']\
        \ += 1\n            miners[author]['total_score'] += weights['feature'] -\
        \ weights['commit']\n        elif 'docs' in commit_message or 'documentation'\
        \ in commit_message:\n            miners[author]['contributions']['documentation']\
        \ += 1\n            miners[author]['total_score'] += weights['documentation']\
        \ - weights['commit']\n        elif 'security' in commit_message or 'sec'\
        \ in commit_message:\n            miners[author]['contributions']['security']\
        \ += 1\n            miners[author]['total_score'] += weights['security'] -\
        \ weights['commit']\n        \n        miners[author]['details'].append({\n\
        \            'type': 'commit',\n            'sha': commit.sha[:8],\n     \
        \       'message': commit.commit.message.split('\\\\n')[0][:100],\n      \
        \      'date': commit.commit.author.date.isoformat(),\n            'score':\
        \ weights['commit']\n        })\n\nprint(f'‚úÖ Analyzed {sum(1 for _ in commits)}\
        \ commits')\n\n# Track pull requests\nprint('\U0001F504 Analyzing pull requests...')\n\
        prs = repo.get_pulls(state='all', sort='updated', direction='desc')\npr_count\
        \ = 0\nfor pr in prs:\n    if pr.updated_at < cutoff_date:\n        break\n\
        \    pr_count += 1\n    \n    if pr.user:\n        author = pr.user.login\n\
        \        miners[author]['contributions']['pull_requests'] += 1\n        miners[author]['total_score']\
        \ += weights['pull_request']\n        \n        miners[author]['details'].append({\n\
        \            'type': 'pull_request',\n            'number': pr.number,\n \
        \           'title': pr.title[:100],\n            'state': pr.state,\n   \
        \         'date': pr.created_at.isoformat(),\n            'score': weights['pull_request']\n\
        \        })\n\nprint(f'‚úÖ Analyzed {pr_count} pull requests')\n\n# Track issues\n\
        print('\U0001F41B Analyzing issues...')\nissues = repo.get_issues(state='all',\
        \ sort='updated', direction='desc')\nissue_count = 0\nfor issue in issues:\n\
        \    if issue.updated_at < cutoff_date:\n        break\n    if issue.pull_request:\
        \  # Skip PRs (already counted)\n        continue\n    issue_count += 1\n\
        \    \n    if issue.user:\n        author = issue.user.login\n        miners[author]['contributions']['issues']\
        \ += 1\n        miners[author]['total_score'] += weights['issue']\n      \
        \  \n        miners[author]['details'].append({\n            'type': 'issue',\n\
        \            'number': issue.number,\n            'title': issue.title[:100],\n\
        \            'state': issue.state,\n            'date': issue.created_at.isoformat(),\n\
        \            'score': weights['issue']\n        })\n\nprint(f'‚úÖ Analyzed {issue_count}\
        \ issues')\n\n# Track reviews\nprint('\U0001F440 Analyzing reviews...')\n\
        review_count = 0\nfor pr in repo.get_pulls(state='all', sort='updated', direction='desc'):\n\
        \    if pr.updated_at < cutoff_date:\n        break\n    \n    reviews = pr.get_reviews()\n\
        \    for review in reviews:\n        if review.submitted_at and review.submitted_at\
        \ >= cutoff_date:\n            review_count += 1\n            if review.user:\n\
        \                author = review.user.login\n                miners[author]['contributions']['reviews']\
        \ += 1\n                miners[author]['total_score'] += weights['review']\n\
        \                \n                miners[author]['details'].append({\n  \
        \                  'type': 'review',\n                    'pr_number': pr.number,\n\
        \                    'state': review.state,\n                    'date': review.submitted_at.isoformat(),\n\
        \                    'score': weights['review']\n                })\n\nprint(f'‚úÖ\
        \ Analyzed {review_count} reviews')\n\n# Get user profiles\nprint('\U0001F464\
        \ Fetching user profiles...')\nfor username in miners.keys():\n    try:\n\
        \        user = github.get_user(username)\n        miners[username]['profile']\
        \ = {\n            'name': user.name or username,\n            'avatar_url':\
        \ user.avatar_url,\n            'public_repos': user.public_repos,\n     \
        \       'followers': user.followers,\n            'created_at': user.created_at.isoformat()\
        \ if user.created_at else None\n        }\n    except Exception as e:\n  \
        \      print(f'‚ö†Ô∏è Could not fetch profile for {username}: {e}')\n        miners[username]['profile']\
        \ = {'name': username}\n\n# Calculate rewards\nbase_multiplier = int(os.environ.get('BASE_REWARD_MULTIPLIER',\
        \ 100))\ntotal_score = sum(miner['total_score'] for miner in miners.values())\n\
        \nfor username, data in miners.items():\n    if total_score > 0:\n       \
        \ reward_percentage = (data['total_score'] / total_score) * 100\n        estimated_tokens\
        \ = (data['total_score'] * base_multiplier) / 100\n    else:\n        reward_percentage\
        \ = 0\n        estimated_tokens = 0\n    \n    miners[username]['rewards']\
        \ = {\n        'score_percentage': reward_percentage,\n        'estimated_tokens':\
        \ estimated_tokens,\n        'rank': 0  # Will be set later\n    }\n\n# Rank\
        \ miners by total score\nsorted_miners = sorted(miners.items(), key=lambda\
        \ x: x[1]['total_score'], reverse=True)\nfor rank, (username, data) in enumerate(sorted_miners,\
        \ 1):\n    miners[username]['rewards']['rank'] = rank\n\n# Create comprehensive\
        \ report\nreport_data = {\n    'timestamp': datetime.now(timezone.utc).isoformat(),\n\
        \    'tracking_period_days': tracking_days,\n    'cutoff_date': cutoff_date.isoformat(),\n\
        \    'total_miners': len(miners),\n    'total_contributions': sum(sum(miner['contributions'].values())\
        \ for miner in miners.values()),\n    'total_score': total_score,\n    'contribution_weights':\
        \ weights,\n    'miners': dict(miners)\n}\n\n# Save detailed report\nos.makedirs('mining-reports',\
        \ exist_ok=True)\nreport_filename = f'mining-reports/contributions-{datetime.now().strftime(\\\
        \"%Y%m%d-%H%M%S\\\")}.json'\n\nwith open(report_filename, 'w') as f:\n   \
        \ json.dump(report_data, f, indent=2, default=str)\n\nprint(f'\\\\n‚õèÔ∏è MINING\
        \ CONTRIBUTION SUMMARY:')\nprint(f'\U0001F4C5 Period: Last {tracking_days}\
        \ days')\nprint(f'\U0001F465 Total Miners: {len(miners)}')\nprint(f'\U0001F4CA\
        \ Total Contributions: {sum(sum(miner[\\\"contributions\\\"].values()) for\
        \ miner in miners.values())}')\nprint(f'\U0001F3C6 Total Score: {total_score}')\n\
        print(f'\U0001F4B0 Base Reward Multiplier: {base_multiplier}x')\n\nprint('\\\
        \\n\U0001F3C6 TOP MINERS:')\nfor i, (username, data) in enumerate(sorted_miners[:10]):\n\
        \    name = data['profile'].get('name', username)\n    score = data['total_score']\n\
        \    tokens = data['rewards']['estimated_tokens']\n    print(f'   #{i+1} {name}\
        \ ({username}): {score} points ‚Üí {tokens:.2f} XMRT')\n\nprint(f'\\\\n‚úÖ Detailed\
        \ report saved to {report_filename}')\n\"\n"
    - name: üèÜ Generate Leaderboard
      run: "python -c \"\nimport json\nimport os\nfrom datetime import datetime\n\
        from glob import glob\n\n# Find latest report\nreports = sorted(glob('mining-reports/contributions-*.json'),\
        \ reverse=True)\nif not reports:\n    print('‚ùå No contribution reports found')\n\
        \    exit(1)\n\nwith open(reports[0]) as f:\n    report_data = json.load(f)\n\
        \nminers = report_data['miners']\nsorted_miners = sorted(miners.items(), key=lambda\
        \ x: x[1]['total_score'], reverse=True)\n\n# Generate markdown leaderboard\n\
        leaderboard = []\nleaderboard.append('# \U0001F3C6 XMRT Miner Contribution\
        \ Leaderboard')\nleaderboard.append('')\nleaderboard.append(f'**Period**:\
        \ Last {report_data[\\\"tracking_period_days\\\"]} days')\nleaderboard.append(f'**Generated**:\
        \ {datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")} UTC')\nleaderboard.append(f'**Total\
        \ Miners**: {report_data[\\\"total_miners\\\"]}')\nleaderboard.append(f'**Total\
        \ Contributions**: {report_data[\\\"total_contributions\\\"]}')\nleaderboard.append('')\n\
        \nleaderboard.append('## \U0001F947 Top Contributors')\nleaderboard.append('')\n\
        leaderboard.append('| Rank | Miner | Score | Estimated XMRT | Contributions\
        \ |')\nleaderboard.append('|------|-------|-------|----------------|---------------|')\n\
        \nfor i, (username, data) in enumerate(sorted_miners[:20]):\n    rank = i\
        \ + 1\n    name = data['profile'].get('name', username)\n    score = data['total_score']\n\
        \    tokens = data['rewards']['estimated_tokens']\n    \n    # Count contributions\n\
        \    contributions = []\n    for contrib_type, count in data['contributions'].items():\n\
        \        if count > 0:\n            contributions.append(f'{count} {contrib_type}')\n\
        \    contrib_str = ', '.join(contributions) if contributions else 'None'\n\
        \    \n    # Rank emoji\n    if rank == 1:\n        rank_emoji = '\U0001F947\
        '\n    elif rank == 2:\n        rank_emoji = '\U0001F948'\n    elif rank ==\
        \ 3:\n        rank_emoji = '\U0001F949'\n    else:\n        rank_emoji = f'#{rank}'\n\
        \    \n    leaderboard.append(f'| {rank_emoji} | **{name}** (@{username})\
        \ | {score} | {tokens:.2f} | {contrib_str} |')\n\nleaderboard.append('')\n\
        leaderboard.append('## \U0001F4CA Contribution Breakdown')\nleaderboard.append('')\n\
        \n# Aggregate contribution types\ntotal_contributions = {}\nfor username,\
        \ data in miners.items():\n    for contrib_type, count in data['contributions'].items():\n\
        \        total_contributions[contrib_type] = total_contributions.get(contrib_type,\
        \ 0) + count\n\nleaderboard.append('| Contribution Type | Count | Weight |\
        \ Total Score |')\nleaderboard.append('|-------------------|-------|--------|-------------|')\n\
        \nweights = report_data['contribution_weights']\nfor contrib_type, count in\
        \ sorted(total_contributions.items(), key=lambda x: x[1], reverse=True):\n\
        \    weight = weights.get(contrib_type, weights.get(contrib_type.rstrip('s'),\
        \ 0))\n    total_score = count * weight\n    leaderboard.append(f'| {contrib_type.replace(\\\
        \"_\\\", \\\" \\\").title()} | {count} | {weight} | {total_score} |')\n\n\
        leaderboard.append('')\nleaderboard.append('## \U0001F4B0 Reward Distribution')\n\
        leaderboard.append('')\nleaderboard.append(f'- **Base Multiplier**: {os.environ.get(\\\
        \"BASE_REWARD_MULTIPLIER\\\", 100)}x')\nleaderboard.append(f'- **Total Score\
        \ Pool**: {report_data[\\\"total_score\\\"]}')\nleaderboard.append(f'- **Estimated\
        \ Total XMRT**: {sum(data[\\\"rewards\\\"][\\\"estimated_tokens\\\"] for data\
        \ in miners.values()):.2f}')\nleaderboard.append('')\n\n# Top 5 reward recipients\n\
        leaderboard.append('### \U0001F3AF Top Reward Recipients')\nfor i, (username,\
        \ data) in enumerate(sorted_miners[:5]):\n    name = data['profile'].get('name',\
        \ username)\n    tokens = data['rewards']['estimated_tokens']\n    percentage\
        \ = data['rewards']['score_percentage']\n    leaderboard.append(f'{i+1}. **{name}**:\
        \ {tokens:.2f} XMRT ({percentage:.1f}% of pool)')\n\nleaderboard.append('')\n\
        leaderboard.append('---')\nleaderboard.append('*Rewards are estimated based\
        \ on contribution scores and may be subject to final review and adjustment.*')\n\
        \n# Save leaderboard\nleaderboard_content = '\\\\n'.join(leaderboard)\nwith\
        \ open('MINER_LEADERBOARD.md', 'w') as f:\n    f.write(leaderboard_content)\n\
        \nprint('‚úÖ Leaderboard generated')\nprint(leaderboard_content)\n\"\n"
    - name: üíé Calculate Reward Tokens
      if: github.event.inputs.reward_calculation == 'true' || github.event_name ==
        'schedule'
      run: "python -c \"\nimport json\nimport os\nfrom datetime import datetime\n\
        from glob import glob\n\n# Find latest report\nreports = sorted(glob('mining-reports/contributions-*.json'),\
        \ reverse=True)\nif not reports:\n    print('‚ùå No contribution reports found')\n\
        \    exit(1)\n\nwith open(reports[0]) as f:\n    report_data = json.load(f)\n\
        \nminers = report_data['miners']\n\n# Create reward distribution file\nreward_distribution\
        \ = {\n    'timestamp': datetime.now().isoformat(),\n    'period_days': report_data['tracking_period_days'],\n\
        \    'total_miners': len(miners),\n    'total_score': report_data['total_score'],\n\
        \    'base_multiplier': int(os.environ.get('BASE_REWARD_MULTIPLIER', 100)),\n\
        \    'rewards': []\n}\n\n# Sort miners by score\nsorted_miners = sorted(miners.items(),\
        \ key=lambda x: x[1]['total_score'], reverse=True)\n\nfor username, data in\
        \ sorted_miners:\n    if data['total_score'] > 0:  # Only include miners with\
        \ contributions\n        reward_entry = {\n            'username': username,\n\
        \            'name': data['profile'].get('name', username),\n            'rank':\
        \ data['rewards']['rank'],\n            'total_score': data['total_score'],\n\
        \            'score_percentage': data['rewards']['score_percentage'],\n  \
        \          'estimated_tokens': data['rewards']['estimated_tokens'],\n    \
        \        'contributions': data['contributions'],\n            'wallet_address':\
        \ None  # To be filled manually or via separate process\n        }\n     \
        \   reward_distribution['rewards'].append(reward_entry)\n\n# Save reward distribution\n\
        reward_filename = f'mining-reports/reward-distribution-{datetime.now().strftime(\\\
        \"%Y%m%d-%H%M%S\\\")}.json'\nwith open(reward_filename, 'w') as f:\n    json.dump(reward_distribution,\
        \ f, indent=2)\n\nprint(f'\U0001F48E REWARD CALCULATION COMPLETE')\nprint(f'\U0001F4C4\
        \ Reward distribution saved to: {reward_filename}')\nprint(f'\U0001F4B0 Total\
        \ estimated XMRT to distribute: {sum(r[\\\"estimated_tokens\\\"] for r in\
        \ reward_distribution[\\\"rewards\\\"]):.2f}')\nprint(f'\U0001F465 Miners\
        \ eligible for rewards: {len(reward_distribution[\\\"rewards\\\"])}')\n\n\
        # Create summary for top miners\nprint('\\\\n\U0001F3C6 TOP REWARD RECIPIENTS:')\n\
        for i, reward in enumerate(reward_distribution['rewards'][:10]):\n    print(f'\
        \   #{i+1} {reward[\\\"name\\\"]} (@{reward[\\\"username\\\"]}): {reward[\\\
        \"estimated_tokens\\\"]:.2f} XMRT')\n\"\n"
    - name: üìä Generate Contribution Chart
      run: "python -c \"\nimport json\nimport matplotlib.pyplot as plt\nimport seaborn\
        \ as sns\nfrom datetime import datetime\nfrom glob import glob\nimport pandas\
        \ as pd\n\n# Set style\nplt.style.use('seaborn-v0_8')\nsns.set_palette('husl')\n\
        \n# Find latest report\nreports = sorted(glob('mining-reports/contributions-*.json'),\
        \ reverse=True)\nif not reports:\n    print('‚ùå No contribution reports found')\n\
        \    exit(1)\n\nwith open(reports[0]) as f:\n    report_data = json.load(f)\n\
        \nminers = report_data['miners']\n\n# Create contribution type chart\nfig,\
        \ ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))\nfig.suptitle('XMRT\
        \ Miner Contribution Analysis', fontsize=16, fontweight='bold')\n\n# 1. Top\
        \ miners by score\nsorted_miners = sorted(miners.items(), key=lambda x: x[1]['total_score'],\
        \ reverse=True)[:10]\nnames = [data['profile'].get('name', username)[:15]\
        \ for username, data in sorted_miners]\nscores = [data['total_score'] for\
        \ username, data in sorted_miners]\n\nax1.barh(names, scores, color='skyblue')\n\
        ax1.set_title('Top 10 Miners by Score')\nax1.set_xlabel('Contribution Score')\n\
        \n# 2. Contribution type distribution\ncontrib_totals = {}\nfor username,\
        \ data in miners.items():\n    for contrib_type, count in data['contributions'].items():\n\
        \        contrib_totals[contrib_type] = contrib_totals.get(contrib_type, 0)\
        \ + count\n\nif contrib_totals:\n    labels = list(contrib_totals.keys())\n\
        \    sizes = list(contrib_totals.values())\n    ax2.pie(sizes, labels=labels,\
        \ autopct='%1.1f%%', startangle=90)\n    ax2.set_title('Contribution Type\
        \ Distribution')\n\n# 3. Score distribution\nall_scores = [data['total_score']\
        \ for data in miners.values() if data['total_score'] > 0]\nif all_scores:\n\
        \    ax3.hist(all_scores, bins=20, color='lightgreen', alpha=0.7, edgecolor='black')\n\
        \    ax3.set_title('Score Distribution')\n    ax3.set_xlabel('Contribution\
        \ Score')\n    ax3.set_ylabel('Number of Miners')\n\n# 4. Reward distribution\n\
        rewards = [data['rewards']['estimated_tokens'] for data in miners.values()\
        \ if data['total_score'] > 0]\nif rewards:\n    ax4.hist(rewards, bins=20,\
        \ color='gold', alpha=0.7, edgecolor='black')\n    ax4.set_title('Estimated\
        \ XMRT Reward Distribution')\n    ax4.set_xlabel('Estimated XMRT Tokens')\n\
        \    ax4.set_ylabel('Number of Miners')\n\nplt.tight_layout()\n\n# Save chart\n\
        chart_filename = f'mining-reports/contribution-chart-{datetime.now().strftime(\\\
        \"%Y%m%d-%H%M%S\\\")}.png'\nplt.savefig(chart_filename, dpi=300, bbox_inches='tight')\n\
        plt.close()\n\nprint(f'\U0001F4CA Contribution chart saved to: {chart_filename}')\n\
        \"\n"
    - name: üì§ Upload Mining Reports
      uses: actions/upload-artifact@v4
      with:
        name: xmrt-mining-reports-${{ github.run_number }}
        path: 'mining-reports/

          MINER_LEADERBOARD.md

          '
        retention-days: 90
    - name: üìã Add Mining Summary to Step Summary
      run: "if [ -f MINER_LEADERBOARD.md ]; then\n  cat MINER_LEADERBOARD.md >> $GITHUB_STEP_SUMMARY\n\
        fi\n"
  update-readme-leaderboard:
    name: üìù Update README with Leaderboard
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: track-contributions
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    steps:
    - name: üì• Checkout Repository
      uses: actions/checkout@v4
    - name: üì• Download Mining Reports
      uses: actions/download-artifact@v4
      with:
        name: xmrt-mining-reports-${{ github.run_number }}
    - name: üìù Update README with Leaderboard
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: "# Check if leaderboard exists\nif [ ! -f MINER_LEADERBOARD.md ]; then\n\
        \  echo '‚ùå Leaderboard file not found'\n  exit 1\nfi\n\n# Create updated README\
        \ section\ncat > leaderboard_section.md << 'EOF'\n\n## \U0001F3C6 XMRT Miner\
        \ Contribution Leaderboard\n\nEOF\n\n# Add leaderboard content (skip the title)\n\
        tail -n +3 MINER_LEADERBOARD.md >> leaderboard_section.md\n\necho '‚úÖ Leaderboard\
        \ section prepared for README update'\n"
    - name: üöÄ Commit Updated Leaderboard
      uses: stefanzweifel/git-auto-commit-action@v4
      with:
        commit_message: üèÜ Update miner contribution leaderboard - ${{ github.run_number
          }}
        file_pattern: README.md MINER_LEADERBOARD.md
        commit_user_name: XMRT Miner Tracker
        commit_user_email: miner-tracker@xmrt-ecosystem.com
permissions:
  contents: read
  actions: read
  checks: write
  pull-requests: read
