name: ‚õèÔ∏è XMRT Miner Contribution Tracker

on:
  push:
    branches: [ main, develop ]
  pull_request:
    types: [opened, closed, merged]
  issues:
    types: [opened, closed]
  release:
    types: [published]
  schedule:
    # Track contributions daily at midnight UTC
    - cron: '0 0 * * *'
  workflow_dispatch:
    inputs:
      tracking_period:
        description: 'Period to track contributions'
        required: true
        default: '7'
        type: choice
        options:
        - '1'
        - '7'
        - '30'
        - '90'
      reward_calculation:
        description: 'Calculate rewards for contributions'
        required: true
        default: 'true'
        type: boolean

env:
  XMRT_TOKEN_SYMBOL: 'XMRT'
  BASE_REWARD_MULTIPLIER: 100
  CONTRIBUTION_WEIGHTS: |
    {
      "commit": 10,
      "pull_request": 25,
      "issue": 15,
      "review": 20,
      "release": 50,
      "documentation": 30,
      "bug_fix": 40,
      "feature": 35,
      "security": 60
    }

jobs:
  track-contributions:
    name: ‚õèÔ∏è Track Miner Contributions
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
    - name: üì• Checkout Repository
      uses: actions/checkout@v4
      
    - name: üêç Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        
    - name: üîß Install Dependencies
      run: |
        python -m pip install --upgrade pip
        pip install PyGithub python-dotenv requests pandas matplotlib seaborn
        
    - name: ‚õèÔ∏è Analyze Miner Contributions
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        TRACKING_DAYS: ${{ github.event.inputs.tracking_period || '7' }}
      run: |
        python -c "
        import json
        import os
        from datetime import datetime, timezone, timedelta
        from github import Github, Auth
        from collections import defaultdict
        import requests
        
        # Initialize GitHub
        auth = Auth.Token(os.environ['GITHUB_TOKEN'])
        github = Github(auth=auth)
        repo = github.get_repo('${{ github.repository }}')
        
        # Configuration
        tracking_days = int(os.environ.get('TRACKING_DAYS', 7))
        cutoff_date = datetime.now(timezone.utc) - timedelta(days=tracking_days)
        
        # Contribution weights
        weights = {
            'commit': 10,
            'pull_request': 25,
            'issue': 15,
            'review': 20,
            'release': 50,
            'documentation': 30,
            'bug_fix': 40,
            'feature': 35,
            'security': 60
        }
        
        print(f'‚õèÔ∏è Tracking contributions for the last {tracking_days} days...')
        print(f'üìÖ Cutoff date: {cutoff_date.strftime(\"%Y-%m-%d %H:%M:%S\")} UTC')
        
        # Initialize contribution tracking
        miners = defaultdict(lambda: {
            'contributions': defaultdict(int),
            'total_score': 0,
            'details': [],
            'profile': {}
        })
        
        # Track commits
        print('üìù Analyzing commits...')
        commits = repo.get_commits(since=cutoff_date)
        for commit in commits:
            if commit.author:
                author = commit.author.login
                miners[author]['contributions']['commits'] += 1
                miners[author]['total_score'] += weights['commit']
                
                # Analyze commit for special categories
                commit_message = commit.commit.message.lower()
                if 'fix' in commit_message or 'bug' in commit_message:
                    miners[author]['contributions']['bug_fixes'] += 1
                    miners[author]['total_score'] += weights['bug_fix'] - weights['commit']
                elif 'feat' in commit_message or 'feature' in commit_message:
                    miners[author]['contributions']['features'] += 1
                    miners[author]['total_score'] += weights['feature'] - weights['commit']
                elif 'docs' in commit_message or 'documentation' in commit_message:
                    miners[author]['contributions']['documentation'] += 1
                    miners[author]['total_score'] += weights['documentation'] - weights['commit']
                elif 'security' in commit_message or 'sec' in commit_message:
                    miners[author]['contributions']['security'] += 1
                    miners[author]['total_score'] += weights['security'] - weights['commit']
                
                miners[author]['details'].append({
                    'type': 'commit',
                    'sha': commit.sha[:8],
                    'message': commit.commit.message.split('\\n')[0][:100],
                    'date': commit.commit.author.date.isoformat(),
                    'score': weights['commit']
                })
        
        print(f'‚úÖ Analyzed {sum(1 for _ in commits)} commits')
        
        # Track pull requests
        print('üîÑ Analyzing pull requests...')
        prs = repo.get_pulls(state='all', sort='updated', direction='desc')
        pr_count = 0
        for pr in prs:
            if pr.updated_at < cutoff_date:
                break
            pr_count += 1
            
            if pr.user:
                author = pr.user.login
                miners[author]['contributions']['pull_requests'] += 1
                miners[author]['total_score'] += weights['pull_request']
                
                miners[author]['details'].append({
                    'type': 'pull_request',
                    'number': pr.number,
                    'title': pr.title[:100],
                    'state': pr.state,
                    'date': pr.created_at.isoformat(),
                    'score': weights['pull_request']
                })
        
        print(f'‚úÖ Analyzed {pr_count} pull requests')
        
        # Track issues
        print('üêõ Analyzing issues...')
        issues = repo.get_issues(state='all', sort='updated', direction='desc')
        issue_count = 0
        for issue in issues:
            if issue.updated_at < cutoff_date:
                break
            if issue.pull_request:  # Skip PRs (already counted)
                continue
            issue_count += 1
            
            if issue.user:
                author = issue.user.login
                miners[author]['contributions']['issues'] += 1
                miners[author]['total_score'] += weights['issue']
                
                miners[author]['details'].append({
                    'type': 'issue',
                    'number': issue.number,
                    'title': issue.title[:100],
                    'state': issue.state,
                    'date': issue.created_at.isoformat(),
                    'score': weights['issue']
                })
        
        print(f'‚úÖ Analyzed {issue_count} issues')
        
        # Track reviews
        print('üëÄ Analyzing reviews...')
        review_count = 0
        for pr in repo.get_pulls(state='all', sort='updated', direction='desc'):
            if pr.updated_at < cutoff_date:
                break
            
            reviews = pr.get_reviews()
            for review in reviews:
                if review.submitted_at and review.submitted_at >= cutoff_date:
                    review_count += 1
                    if review.user:
                        author = review.user.login
                        miners[author]['contributions']['reviews'] += 1
                        miners[author]['total_score'] += weights['review']
                        
                        miners[author]['details'].append({
                            'type': 'review',
                            'pr_number': pr.number,
                            'state': review.state,
                            'date': review.submitted_at.isoformat(),
                            'score': weights['review']
                        })
        
        print(f'‚úÖ Analyzed {review_count} reviews')
        
        # Get user profiles
        print('üë§ Fetching user profiles...')
        for username in miners.keys():
            try:
                user = github.get_user(username)
                miners[username]['profile'] = {
                    'name': user.name or username,
                    'avatar_url': user.avatar_url,
                    'public_repos': user.public_repos,
                    'followers': user.followers,
                    'created_at': user.created_at.isoformat() if user.created_at else None
                }
            except Exception as e:
                print(f'‚ö†Ô∏è Could not fetch profile for {username}: {e}')
                miners[username]['profile'] = {'name': username}
        
        # Calculate rewards
        base_multiplier = int(os.environ.get('BASE_REWARD_MULTIPLIER', 100))
        total_score = sum(miner['total_score'] for miner in miners.values())
        
        for username, data in miners.items():
            if total_score > 0:
                reward_percentage = (data['total_score'] / total_score) * 100
                estimated_tokens = (data['total_score'] * base_multiplier) / 100
            else:
                reward_percentage = 0
                estimated_tokens = 0
            
            miners[username]['rewards'] = {
                'score_percentage': reward_percentage,
                'estimated_tokens': estimated_tokens,
                'rank': 0  # Will be set later
            }
        
        # Rank miners by total score
        sorted_miners = sorted(miners.items(), key=lambda x: x[1]['total_score'], reverse=True)
        for rank, (username, data) in enumerate(sorted_miners, 1):
            miners[username]['rewards']['rank'] = rank
        
        # Create comprehensive report
        report_data = {
            'timestamp': datetime.now(timezone.utc).isoformat(),
            'tracking_period_days': tracking_days,
            'cutoff_date': cutoff_date.isoformat(),
            'total_miners': len(miners),
            'total_contributions': sum(sum(miner['contributions'].values()) for miner in miners.values()),
            'total_score': total_score,
            'contribution_weights': weights,
            'miners': dict(miners)
        }
        
        # Save detailed report
        os.makedirs('mining-reports', exist_ok=True)
        report_filename = f'mining-reports/contributions-{datetime.now().strftime(\"%Y%m%d-%H%M%S\")}.json'
        
        with open(report_filename, 'w') as f:
            json.dump(report_data, f, indent=2, default=str)
        
        print(f'\\n‚õèÔ∏è MINING CONTRIBUTION SUMMARY:')
        print(f'üìÖ Period: Last {tracking_days} days')
        print(f'üë• Total Miners: {len(miners)}')
        print(f'üìä Total Contributions: {sum(sum(miner[\"contributions\"].values()) for miner in miners.values())}')
        print(f'üèÜ Total Score: {total_score}')
        print(f'üí∞ Base Reward Multiplier: {base_multiplier}x')
        
        print('\\nüèÜ TOP MINERS:')
        for i, (username, data) in enumerate(sorted_miners[:10]):
            name = data['profile'].get('name', username)
            score = data['total_score']
            tokens = data['rewards']['estimated_tokens']
            print(f'   #{i+1} {name} ({username}): {score} points ‚Üí {tokens:.2f} XMRT')
        
        print(f'\\n‚úÖ Detailed report saved to {report_filename}')
        "
        
    - name: üèÜ Generate Leaderboard
      run: |
        python -c "
        import json
        import os
        from datetime import datetime
        from glob import glob
        
        # Find latest report
        reports = sorted(glob('mining-reports/contributions-*.json'), reverse=True)
        if not reports:
            print('‚ùå No contribution reports found')
            exit(1)
        
        with open(reports[0]) as f:
            report_data = json.load(f)
        
        miners = report_data['miners']
        sorted_miners = sorted(miners.items(), key=lambda x: x[1]['total_score'], reverse=True)
        
        # Generate markdown leaderboard
        leaderboard = []
        leaderboard.append('# üèÜ XMRT Miner Contribution Leaderboard')
        leaderboard.append('')
        leaderboard.append(f'**Period**: Last {report_data[\"tracking_period_days\"]} days')
        leaderboard.append(f'**Generated**: {datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")} UTC')
        leaderboard.append(f'**Total Miners**: {report_data[\"total_miners\"]}')
        leaderboard.append(f'**Total Contributions**: {report_data[\"total_contributions\"]}')
        leaderboard.append('')
        
        leaderboard.append('## ü•á Top Contributors')
        leaderboard.append('')
        leaderboard.append('| Rank | Miner | Score | Estimated XMRT | Contributions |')
        leaderboard.append('|------|-------|-------|----------------|---------------|')
        
        for i, (username, data) in enumerate(sorted_miners[:20]):
            rank = i + 1
            name = data['profile'].get('name', username)
            score = data['total_score']
            tokens = data['rewards']['estimated_tokens']
            
            # Count contributions
            contributions = []
            for contrib_type, count in data['contributions'].items():
                if count > 0:
                    contributions.append(f'{count} {contrib_type}')
            contrib_str = ', '.join(contributions) if contributions else 'None'
            
            # Rank emoji
            if rank == 1:
                rank_emoji = 'ü•á'
            elif rank == 2:
                rank_emoji = 'ü•à'
            elif rank == 3:
                rank_emoji = 'ü•â'
            else:
                rank_emoji = f'#{rank}'
            
            leaderboard.append(f'| {rank_emoji} | **{name}** (@{username}) | {score} | {tokens:.2f} | {contrib_str} |')
        
        leaderboard.append('')
        leaderboard.append('## üìä Contribution Breakdown')
        leaderboard.append('')
        
        # Aggregate contribution types
        total_contributions = {}
        for username, data in miners.items():
            for contrib_type, count in data['contributions'].items():
                total_contributions[contrib_type] = total_contributions.get(contrib_type, 0) + count
        
        leaderboard.append('| Contribution Type | Count | Weight | Total Score |')
        leaderboard.append('|-------------------|-------|--------|-------------|')
        
        weights = report_data['contribution_weights']
        for contrib_type, count in sorted(total_contributions.items(), key=lambda x: x[1], reverse=True):
            weight = weights.get(contrib_type, weights.get(contrib_type.rstrip('s'), 0))
            total_score = count * weight
            leaderboard.append(f'| {contrib_type.replace(\"_\", \" \").title()} | {count} | {weight} | {total_score} |')
        
        leaderboard.append('')
        leaderboard.append('## üí∞ Reward Distribution')
        leaderboard.append('')
        leaderboard.append(f'- **Base Multiplier**: {os.environ.get(\"BASE_REWARD_MULTIPLIER\", 100)}x')
        leaderboard.append(f'- **Total Score Pool**: {report_data[\"total_score\"]}')
        leaderboard.append(f'- **Estimated Total XMRT**: {sum(data[\"rewards\"][\"estimated_tokens\"] for data in miners.values()):.2f}')
        leaderboard.append('')
        
        # Top 5 reward recipients
        leaderboard.append('### üéØ Top Reward Recipients')
        for i, (username, data) in enumerate(sorted_miners[:5]):
            name = data['profile'].get('name', username)
            tokens = data['rewards']['estimated_tokens']
            percentage = data['rewards']['score_percentage']
            leaderboard.append(f'{i+1}. **{name}**: {tokens:.2f} XMRT ({percentage:.1f}% of pool)')
        
        leaderboard.append('')
        leaderboard.append('---')
        leaderboard.append('*Rewards are estimated based on contribution scores and may be subject to final review and adjustment.*')
        
        # Save leaderboard
        leaderboard_content = '\\n'.join(leaderboard)
        with open('MINER_LEADERBOARD.md', 'w') as f:
            f.write(leaderboard_content)
        
        print('‚úÖ Leaderboard generated')
        print(leaderboard_content)
        "
        
    - name: üíé Calculate Reward Tokens
      if: github.event.inputs.reward_calculation == 'true' || github.event_name == 'schedule'
      run: |
        python -c "
        import json
        import os
        from datetime import datetime
        from glob import glob
        
        # Find latest report
        reports = sorted(glob('mining-reports/contributions-*.json'), reverse=True)
        if not reports:
            print('‚ùå No contribution reports found')
            exit(1)
        
        with open(reports[0]) as f:
            report_data = json.load(f)
        
        miners = report_data['miners']
        
        # Create reward distribution file
        reward_distribution = {
            'timestamp': datetime.now().isoformat(),
            'period_days': report_data['tracking_period_days'],
            'total_miners': len(miners),
            'total_score': report_data['total_score'],
            'base_multiplier': int(os.environ.get('BASE_REWARD_MULTIPLIER', 100)),
            'rewards': []
        }
        
        # Sort miners by score
        sorted_miners = sorted(miners.items(), key=lambda x: x[1]['total_score'], reverse=True)
        
        for username, data in sorted_miners:
            if data['total_score'] > 0:  # Only include miners with contributions
                reward_entry = {
                    'username': username,
                    'name': data['profile'].get('name', username),
                    'rank': data['rewards']['rank'],
                    'total_score': data['total_score'],
                    'score_percentage': data['rewards']['score_percentage'],
                    'estimated_tokens': data['rewards']['estimated_tokens'],
                    'contributions': data['contributions'],
                    'wallet_address': None  # To be filled manually or via separate process
                }
                reward_distribution['rewards'].append(reward_entry)
        
        # Save reward distribution
        reward_filename = f'mining-reports/reward-distribution-{datetime.now().strftime(\"%Y%m%d-%H%M%S\")}.json'
        with open(reward_filename, 'w') as f:
            json.dump(reward_distribution, f, indent=2)
        
        print(f'üíé REWARD CALCULATION COMPLETE')
        print(f'üìÑ Reward distribution saved to: {reward_filename}')
        print(f'üí∞ Total estimated XMRT to distribute: {sum(r[\"estimated_tokens\"] for r in reward_distribution[\"rewards\"]):.2f}')
        print(f'üë• Miners eligible for rewards: {len(reward_distribution[\"rewards\"])}')
        
        # Create summary for top miners
        print('\\nüèÜ TOP REWARD RECIPIENTS:')
        for i, reward in enumerate(reward_distribution['rewards'][:10]):
            print(f'   #{i+1} {reward[\"name\"]} (@{reward[\"username\"]}): {reward[\"estimated_tokens\"]:.2f} XMRT')
        "
        
    - name: üìä Generate Contribution Chart
      run: |
        python -c "
        import json
        import matplotlib.pyplot as plt
        import seaborn as sns
        from datetime import datetime
        from glob import glob
        import pandas as pd
        
        # Set style
        plt.style.use('seaborn-v0_8')
        sns.set_palette('husl')
        
        # Find latest report
        reports = sorted(glob('mining-reports/contributions-*.json'), reverse=True)
        if not reports:
            print('‚ùå No contribution reports found')
            exit(1)
        
        with open(reports[0]) as f:
            report_data = json.load(f)
        
        miners = report_data['miners']
        
        # Create contribution type chart
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
        fig.suptitle('XMRT Miner Contribution Analysis', fontsize=16, fontweight='bold')
        
        # 1. Top miners by score
        sorted_miners = sorted(miners.items(), key=lambda x: x[1]['total_score'], reverse=True)[:10]
        names = [data['profile'].get('name', username)[:15] for username, data in sorted_miners]
        scores = [data['total_score'] for username, data in sorted_miners]
        
        ax1.barh(names, scores, color='skyblue')
        ax1.set_title('Top 10 Miners by Score')
        ax1.set_xlabel('Contribution Score')
        
        # 2. Contribution type distribution
        contrib_totals = {}
        for username, data in miners.items():
            for contrib_type, count in data['contributions'].items():
                contrib_totals[contrib_type] = contrib_totals.get(contrib_type, 0) + count
        
        if contrib_totals:
            labels = list(contrib_totals.keys())
            sizes = list(contrib_totals.values())
            ax2.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=90)
            ax2.set_title('Contribution Type Distribution')
        
        # 3. Score distribution
        all_scores = [data['total_score'] for data in miners.values() if data['total_score'] > 0]
        if all_scores:
            ax3.hist(all_scores, bins=20, color='lightgreen', alpha=0.7, edgecolor='black')
            ax3.set_title('Score Distribution')
            ax3.set_xlabel('Contribution Score')
            ax3.set_ylabel('Number of Miners')
        
        # 4. Reward distribution
        rewards = [data['rewards']['estimated_tokens'] for data in miners.values() if data['total_score'] > 0]
        if rewards:
            ax4.hist(rewards, bins=20, color='gold', alpha=0.7, edgecolor='black')
            ax4.set_title('Estimated XMRT Reward Distribution')
            ax4.set_xlabel('Estimated XMRT Tokens')
            ax4.set_ylabel('Number of Miners')
        
        plt.tight_layout()
        
        # Save chart
        chart_filename = f'mining-reports/contribution-chart-{datetime.now().strftime(\"%Y%m%d-%H%M%S\")}.png'
        plt.savefig(chart_filename, dpi=300, bbox_inches='tight')
        plt.close()
        
        print(f'üìä Contribution chart saved to: {chart_filename}')
        "
        
    - name: üì§ Upload Mining Reports
      uses: actions/upload-artifact@v4
      with:
        name: xmrt-mining-reports-${{ github.run_number }}
        path: |
          mining-reports/
          MINER_LEADERBOARD.md
        retention-days: 90
        
    - name: üìã Add Mining Summary to Step Summary
      run: |
        if [ -f MINER_LEADERBOARD.md ]; then
          cat MINER_LEADERBOARD.md >> $GITHUB_STEP_SUMMARY
        fi

  update-readme-leaderboard:
    name: üìù Update README with Leaderboard
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: track-contributions
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: üì• Checkout Repository
      uses: actions/checkout@v4
      
    - name: üì• Download Mining Reports
      uses: actions/download-artifact@v4
      with:
        name: xmrt-mining-reports-${{ github.run_number }}
        
    - name: üìù Update README with Leaderboard
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # Check if leaderboard exists
        if [ ! -f MINER_LEADERBOARD.md ]; then
          echo '‚ùå Leaderboard file not found'
          exit 1
        fi
        
        # Create updated README section
        cat > leaderboard_section.md << 'EOF'
        
        ## üèÜ XMRT Miner Contribution Leaderboard
        
        EOF
        
        # Add leaderboard content (skip the title)
        tail -n +3 MINER_LEADERBOARD.md >> leaderboard_section.md
        
        echo '‚úÖ Leaderboard section prepared for README update'
        
    - name: üöÄ Commit Updated Leaderboard
      uses: stefanzweifel/git-auto-commit-action@v4
      with:
        commit_message: 'üèÜ Update miner contribution leaderboard - ${{ github.run_number }}'
        file_pattern: 'README.md MINER_LEADERBOARD.md'
        commit_user_name: 'XMRT Miner Tracker'
        commit_user_email: 'miner-tracker@xmrt-ecosystem.com'
