name: ü§ñ Multi-Agent Coordination Cycle
on:
  schedule:
  - cron: 0 */6 * * *
  workflow_dispatch:
    inputs:
      cycle_type:
        description: Type of coordination cycle
        required: false
        default: standard
        type: choice
        options:
        - standard
        - emergency
        - analysis
  push:
    branches:
    - main
    paths:
    - api/**
    - .github/workflows/agent-coordination-cycle.yml
env:
  AGENT_CYCLE_DIR: agent_cycles
  PYTHON_VERSION: '3.11'
  # Main XMRT Ecosystem endpoints
  VERCEL_URL: https://xmrt-ecosystem.vercel.app
  XMRTIO_URL: https://xmrt-ecosystem-0k8i.onrender.com
  STREAMLIT_URL: https://xmrtsuite.streamlit.app
  # XMRT DAO Ecosystem endpoint
  DAO_API_URL: http://localhost:5000
  # xmrtcouncil frontend
  COUNCIL_URL: http://localhost:5173
  # xmrt-eliza agents
  ELIZA_API_URL: http://localhost:3000
jobs:
  coordination-cycle:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: write
      actions: read
      checks: write
      pull-requests: read
    steps:
    - name: üì• Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: üêç Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: pip
    
    - name: üì¶ Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests python-dotenv

    - name: üîç Discover and Health Check All Ecosystem Agents
      id: health_check
      run: |
        python3 << 'EOF'
        import requests
        import json
        from datetime import datetime
        import time

        # Define all agent endpoints across the XMRT ecosystem
        agent_endpoints = {
            # XMRT-Ecosystem agents (Vercel)
            "Eliza Coordinator": {
                "url": "https://xmrt-ecosystem.vercel.app/health",
                "api_url": "https://xmrt-ecosystem.vercel.app/api/tick",
                "repo": "XMRT-Ecosystem",
                "role": "Governor & Coordinator",
                "weight": 1.2,
                "enabled": True
            },
            "Security Guardian": {
                "url": "https://xmrt-ecosystem.vercel.app/api/agents/security",
                "repo": "XMRT-Ecosystem",
                "role": "Security & Privacy",
                "weight": 1.1,
                "enabled": True
            },
            "DeFi Specialist": {
                "url": "https://xmrt-ecosystem.vercel.app/api/agents/defi",
                "repo": "XMRT-Ecosystem",
                "role": "Mining & Tokenomics",
                "weight": 1.05,
                "enabled": True
            },
            "Community Manager": {
                "url": "https://xmrt-ecosystem.vercel.app/api/agents/community",
                "repo": "XMRT-Ecosystem",
                "role": "Adoption & UX",
                "weight": 1.0,
                "enabled": True
            },
            
            # XMRT.io agents (Render)
            "XMRT.io Main Service": {
                "url": "https://xmrt-ecosystem-0k8i.onrender.com/health",
                "api_url": "https://xmrt-ecosystem-0k8i.onrender.com/api/status",
                "repo": "XMRT.io",
                "role": "Digital Ecosystem Hub",
                "weight": 1.15,
                "enabled": True
            },
            "XMRTsuite Analytics": {
                "url": "https://xmrtsuite.streamlit.app",
                "repo": "XMRT.io",
                "role": "Analytics & Insights",
                "weight": 0.95,
                "enabled": True
            },
            
            # XMRT-DAO-Ecosystem agents
            "Autonomous Decision Engine": {
                "url": None,  # No public endpoint, will skip
                "repo": "XMRT-DAO-Ecosystem",
                "role": "Decision Making",
                "weight": 1.1,
                "enabled": False,
                "reason": "No API endpoint available"
            },
            "Autonomous Execution Engine": {
                "url": None,
                "repo": "XMRT-DAO-Ecosystem",
                "role": "Action Execution",
                "weight": 1.0,
                "enabled": False,
                "reason": "No API endpoint available"
            },
            "Autonomous Monitoring Engine": {
                "url": None,
                "repo": "XMRT-DAO-Ecosystem",
                "role": "System Monitoring",
                "weight": 1.0,
                "enabled": False,
                "reason": "No API endpoint available"
            },
            
            # xmrtcouncil (Frontend interface - health check only)
            "XMRT Council Interface": {
                "url": None,  # Frontend only, no health endpoint
                "repo": "xmrtcouncil",
                "role": "Chatbot Interface & Frontend",
                "weight": 0.9,
                "enabled": False,
                "reason": "Frontend only, no API endpoint"
            },
            
            # xmrt-eliza agents
            "Eliza OS Agent": {
                "url": None,  # Would need to be running locally
                "api_url": None,
                "repo": "xmrt-eliza",
                "role": "ElizaOS Integration",
                "weight": 1.1,
                "enabled": False,
                "reason": "Requires local deployment"
            }
        }

        # Perform health checks on enabled agents
        healthy_agents = []
        unhealthy_agents = []
        disabled_agents = []
        
        print("="*80)
        print("üîç XMRT ECOSYSTEM AGENT HEALTH CHECK")
        print("="*80)
        
        for agent_name, config in agent_endpoints.items():
            if not config.get("enabled", False):
                disabled_agents.append({
                    "name": agent_name,
                    "repo": config["repo"],
                    "reason": config.get("reason", "Not enabled")
                })
                print(f"‚è≠Ô∏è  {agent_name} ({config['repo']}): Skipped - {config.get('reason', 'Not enabled')}")
                continue
            
            print(f"\nüîé Testing {agent_name} ({config['repo']})...")
            print(f"   URL: {config['url']}")
            
            max_retries = 3
            for attempt in range(max_retries):
                try:
                    response = requests.get(config['url'], timeout=10)
                    
                    # Handle 402 specifically for retries
                    if response.status_code == 402:
                        if attempt < max_retries - 1:
                            print(f"   ‚ö†Ô∏è  Status 402 (Payment Required/Quota Exceeded). Retrying in {2 ** attempt}s...")
                            time.sleep(2 ** attempt)
                            continue
                        else:
                            # Final failure after all retries
                            unhealthy_agents.append({
                                "name": agent_name,
                                "repo": config["repo"],
                                "status": "‚ùå 402 Quota Exceeded (Failed all retries)",
                                "url": config['url']
                            })
                            print(f"   ‚ùå 402 Quota Exceeded (Failed all retries)")
                            break
                    
                    # Raise exception for other 4xx or 5xx status codes
                    response.raise_for_status() 
                    
                    # Success case (status_code == 200)
                    healthy_agents.append({
                        "name": agent_name,
                        "repo": config["repo"],
                        "role": config["role"],
                        "weight": config["weight"],
                        "url": config['url'],
                        "api_url": config.get('api_url'),
                        "status": "‚úÖ Healthy",
                        "response_time": f"{response.elapsed.total_seconds():.2f}s"
                    })
                    print(f"   ‚úÖ Healthy (Response: {response.status_code}, Time: {response.elapsed.total_seconds():.2f}s)")
                    break # Exit retry loop on success
                        
                except requests.exceptions.Timeout:
                    if attempt < max_retries - 1:
                        print(f"   ‚ùå Timeout. Retrying in {2 ** attempt}s...")
                        time.sleep(2 ** attempt)
                        continue
                    unhealthy_agents.append({
                        "name": agent_name,
                        "repo": config["repo"],
                        "status": "‚ùå Timeout",
                        "url": config['url']
                    })
                    print(f"   ‚ùå Timeout after 10s (Failed all retries)")
                    break
                
                except requests.exceptions.HTTPError as e:
                    status_code = e.response.status_code
                    status_text = f"HTTP Error {status_code}"
                        
                    unhealthy_agents.append({
                        "name": agent_name,
                        "repo": config["repo"],
                        "status": f"‚ùå {status_text}",
                        "url": config['url']
                    })
                    print(f"   ‚ùå {status_text}: {e}")
                    break
                    
                except Exception as e:
                    unhealthy_agents.append({
                        "name": agent_name,
                        "repo": config["repo"],
                        "status": f"‚ùå Error: {str(e)[:50]}",
                        "url": config['url']
                    })
                    print(f"   ‚ùå Error: {e}")
                    break
            else:
                # This block executes if the loop completes without a 'break' (i.e., all retries failed)
                pass # The last error/unhealthy status would have been logged in the last attempt's except block

        # Summary
        print("\n" + "="*80)
        print("üìä HEALTH CHECK SUMMARY")
        print("="*80)
        print(f"‚úÖ Healthy agents: {len(healthy_agents)}")
        print(f"‚ö†Ô∏è  Unhealthy agents: {len(unhealthy_agents)}")
        print(f"‚è≠Ô∏è  Disabled agents: {len(disabled_agents)}")
        print(f"üìä Total agents checked: {len(agent_endpoints)}")
        
        # Save results to file
        results = {
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "healthy": healthy_agents,
            "unhealthy": unhealthy_agents,
            "disabled": disabled_agents,
            "summary": {
                "total": len(agent_endpoints),
                "healthy": len(healthy_agents),
                "unhealthy": len(unhealthy_agents),
                "disabled": len(disabled_agents)
            }
        }
        
        with open('/tmp/health_check_results.json', 'w') as f:
            json.dump(results, f, indent=2)
        
        print(f"\n‚úÖ Health check complete - {len(healthy_agents)} healthy agents found")
        
        # Exit with success if at least one agent is healthy
        import sys
        sys.exit(0 if len(healthy_agents) > 0 else 1)
        EOF
      continue-on-error: true

    - name: ü§ñ Trigger Multi-Agent Coordination
      id: coordination
      run: |
        python3 << 'EOF'
        import requests
        import json
        import os
        from datetime import datetime

        # Load health check results
        with open('/tmp/health_check_results.json', 'r') as f:
            health_results = json.load(f)

        cycle_type = "${{ github.event.inputs.cycle_type || 'standard' }}"
        
        # Create cycle directory
        os.makedirs('${{ env.AGENT_CYCLE_DIR }}', exist_ok=True)

        # Trigger coordination on healthy agents
        coordination_results = []
        
        print("="*80)
              for agent in health_results['healthy']:
            if agent.get('api_url'):
                print(f"\nüì° Coordinating with {agent['name']}...")
                
                max_retries = 3
                for attempt in range(max_retries):
                    try:
                        response = requests.post(
                            agent['api_url'],
                            json={
                                "cycle_type": cycle_type,
                                "timestamp": datetime.utcnow().isoformat() + "Z"
                            },
                            timeout=30
                        )
                        
                        # Handle 402 specifically for retries
                        if response.status_code == 402:
                            if attempt < max_retries - 1:
                                print(f"   ‚ö†Ô∏è  Status 402 (Payment Required/Quota Exceeded). Retrying in {2 ** attempt}s...")
                                time.sleep(2 ** attempt)
                                continue
                            else:
                                # Final failure after all retries
                                coordination_results.append({
                                    "agent": agent['name'],
                                    "status": "‚ùå 402 Quota Exceeded (Failed all retries)"
                                })
                                print(f"   ‚ùå 402 Quota Exceeded (Failed all retries)")
                                break
                        
                        # Raise exception for other 4xx or 5xx status codes
                        response.raise_for_status() 
                        
                        # Success case (status_code == 200)
                        result = response.json() if response.content else {}
                        coordination_results.append({
                            "agent": agent['name'],
                            "status": "‚úÖ Success",
                            "response": result
                        })
                        print(f"   ‚úÖ Coordination successful")
                        break # Exit retry loop on success
                            
                    except requests.exceptions.Timeout:
                        if attempt < max_retries - 1:
                            print(f"   ‚ùå Timeout. Retrying in {2 ** attempt}s...")
                            time.sleep(2 ** attempt)
                            continue
                        coordination_results.append({
                            "agent": agent['name'],
                            "status": "‚ùå Timeout"
                        })
                        print(f"   ‚ùå Timeout after 30s (Failed all retries)")
                        break
                        
                    except requests.exceptions.HTTPError as e:
                        status_code = e.response.status_code
                        status_text = f"HTTP Error {status_code}"
                            
                        coordination_results.append({
                            "agent": agent['name'],
                            "status": f"‚ùå {status_text}"
                        })
                        print(f"   ‚ùå {status_text}: {e}")
                        break
                        
                    except Exception as e:
                        coordination_results.append({
                            "agent": agent['name'],
                            "status": f"‚ùå Error: {str(e)[:50]}"
                        })
                        print(f"   ‚ùå Error: {e}")
                        break
                else:
                    # This block executes if the loop completes without a 'break' (i.e., all retries failed)
                    pass # The last error/unhealthy status would have been logged in the last attempt's except blockate comprehensive cycle report
        cycle_num = datetime.now().strftime('%Y%m%d%H%M')
        report_file = f'${{ env.AGENT_CYCLE_DIR }}/AGENT_CYCLE_{cycle_num}.md'

        with open(report_file, 'w') as f:
            f.write(f'# ü§ñ Multi-Agent Coordination Cycle #{cycle_num}\n\n')
            f.write(f'**Timestamp:** {datetime.utcnow().isoformat()}Z\n')
            f.write(f'**Cycle Type:** {cycle_type}\n')
            f.write(f'**Trigger:** GitHub Actions (Automated)\n\n')
            
            f.write('## üåê XMRT Ecosystem Overview\n\n')
            f.write('This coordination cycle includes agents from:\n')
            f.write('- **XMRT-Ecosystem** (Vercel): Main DAO agents\n')
            f.write('- **XMRT.io** (Render): Digital ecosystem hub\n')
            f.write('- **XMRT-DAO-Ecosystem**: Autonomous engines\n')
            f.write('- **xmrtcouncil**: Frontend interface\n')
            f.write('- **xmrt-eliza**: ElizaOS integration\n\n')
            
            f.write('## üîç Health Check Results\n\n')
            f.write(f'**Summary:**\n')
            f.write(f'- ‚úÖ Healthy: {health_results["summary"]["healthy"]}\n')
            f.write(f'- ‚ö†Ô∏è  Unhealthy: {health_results["summary"]["unhealthy"]}\n')
            f.write(f'- ‚è≠Ô∏è  Disabled: {health_results["summary"]["disabled"]}\n')
            f.write(f'- üìä Total: {health_results["summary"]["total"]}\n\n')
            
            f.write('### ‚úÖ Healthy Agents\n\n')
            f.write('| Agent | Repository | Role | Weight | Response Time |\n')
            f.write('|-------|-----------|------|--------|---------------|\n')
            for agent in health_results['healthy']:
                f.write(f'| {agent["name"]} | {agent["repo"]} | {agent["role"]} | {agent["weight"]} | {agent["response_time"]} |\n')
            
            if health_results['unhealthy']:
                f.write('\n### ‚ö†Ô∏è  Unhealthy Agents\n\n')
                f.write('| Agent | Repository | Status |\n')
                f.write('|-------|-----------|--------|\n')
                for agent in health_results['unhealthy']:
                    f.write(f'| {agent["name"]} | {agent["repo"]} | {agent["status"]} |\n')
            
            if health_results['disabled']:
                f.write('\n### ‚è≠Ô∏è  Disabled Agents\n\n')
                f.write('| Agent | Repository | Reason |\n')
                f.write('|-------|-----------|--------|\n')
                for agent in health_results['disabled']:
                    f.write(f'| {agent["name"]} | {agent["repo"]} | {agent["reason"]} |\n')
            
            f.write('\n## ü§ñ Coordination Results\n\n')
            if coordination_results:
                f.write('| Agent | Status | Details |\n')
                f.write('|-------|--------|----------|\n')
                for result in coordination_results:
                    details = json.dumps(result.get('response', {}))[:100] if result.get('response') else 'N/A'
                    f.write(f'| {result["agent"]} | {result["status"]} | {details} |\n')
            else:
                f.write('*No agents with API endpoints were available for coordination.*\n')
            
            f.write('\n## ‚úÖ Operations Completed\n\n')
            f.write('- ‚úÖ Ecosystem-wide health check performed\n')
            f.write('- ‚úÖ Multi-repository agent discovery\n')
            f.write('- ‚úÖ Agent coordination triggered on available endpoints\n')
            f.write('- ‚úÖ Comprehensive report generated\n\n')
            
            f.write('## üìã Next Steps\n\n')
            f.write('- Next cycle scheduled in 6 hours\n')
            f.write('- Monitoring all ecosystem agents\n')
            f.write('- Awaiting coordination results\n\n')
            
            f.write('---\n')
            f.write('*Generated by XMRT Multi-Repository Agent Coordination System*\n')

        print(f'\n‚úÖ Comprehensive cycle report created: {report_file}')
        print(f'   Coordinated with {len(coordination_results)} agents')
        print(f'   Health checked {health_results["summary"]["total"]} total agents')

        # Set output
        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write(f'cycle_file={report_file}\n')
            f.write(f'cycle_num={cycle_num}\n')
            f.write(f'healthy_count={health_results["summary"]["healthy"]}\n')
        EOF

    - name: üìä Check for changes
      id: check_changes
      run: |
        git add .
        if git diff --staged --quiet; then
          echo "changes=false" >> $GITHUB_OUTPUT
        else
          echo "changes=true" >> $GITHUB_OUTPUT
        fi

    - name: üíæ Commit coordination results
      if: steps.check_changes.outputs.changes == 'true'
      run: |
        git config user.name "Eliza Coordinator"
        git config user.email "eliza@xmrt-ecosystem.io"
        CYCLE_NUM="${{ steps.coordination.outputs.cycle_num }}"
        git add ${{ env.AGENT_CYCLE_DIR }}
        git commit -m "ü§ñ Multi-Agent Coordination Cycle #$CYCLE_NUM [automated]

        ‚úÖ Ecosystem-wide coordination achieved
        üåê Multi-repository agent discovery
        üéØ Coordinated agents across XMRT ecosystem
        üìä Comprehensive health check performed
        üöÄ Enhanced coordination workflow

        Repositories: XMRT-Ecosystem, XMRT.io, XMRT-DAO-Ecosystem, xmrtcouncil, xmrt-eliza
        Healthy Agents: ${{ steps.coordination.outputs.healthy_count }}
        Generated by: XMRT Multi-Repository Agent Coordination System"
        git push

    - name: üìà Create workflow summary
      if: always()
      run: |
        CYCLE_NUM="${{ steps.coordination.outputs.cycle_num }}"
        HEALTHY_COUNT="${{ steps.coordination.outputs.healthy_count }}"
        
        echo "## ü§ñ Multi-Agent Coordination Complete" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Cycle Number:** #$CYCLE_NUM" >> $GITHUB_STEP_SUMMARY
        echo "**Status:** ${{ job.status == 'success' && '‚úÖ Success' || '‚ùå Failed' }}" >> $GITHUB_STEP_SUMMARY
        echo "**Cycle Type:** ${{ github.event.inputs.cycle_type || 'standard' }}" >> $GITHUB_STEP_SUMMARY
        echo "**Timestamp:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
        echo "**Healthy Agents:** $HEALTHY_COUNT" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### üåê XMRT Ecosystem Repositories" >> $GITHUB_STEP_SUMMARY
        echo "- **XMRT-Ecosystem** (Vercel): Main DAO with 4 agents" >> $GITHUB_STEP_SUMMARY
        echo "- **XMRT.io** (Render): Digital ecosystem hub" >> $GITHUB_STEP_SUMMARY
        echo "- **XMRT-DAO-Ecosystem**: Autonomous decision/execution/monitoring engines" >> $GITHUB_STEP_SUMMARY
        echo "- **xmrtcouncil**: Chatbot interface with frontend/backend" >> $GITHUB_STEP_SUMMARY
        echo "- **xmrt-eliza**: ElizaOS integration fork" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### üìä Operations Completed" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ Multi-repository agent discovery" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ Ecosystem-wide health checks" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ Agent coordination triggered" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ Comprehensive cycle report generated" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ steps.check_changes.outputs.changes }}" = "true" ]; then
          echo "- ‚úÖ Results committed to repository" >> $GITHUB_STEP_SUMMARY
        else
          echo "- ‚ÑπÔ∏è  No changes to commit" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Next Cycle:** In 6 hours (automatic)" >> $GITHUB_STEP_SUMMARY
        echo "**Coordination:** Ecosystem-wide multi-agent system" >> $GITHUB_STEP_SUMMARY
